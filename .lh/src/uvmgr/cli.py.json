{
    "sourceFile": "src/uvmgr/cli.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1748231582166,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1748231588557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,13 +87,4 @@\n _add_group(\"ai\", \"uvmgr.cli.commands.ai\")              # optional DSPy extras\n _add_group(\"remote\", \"uvmgr.cli.commands.remote\")\n _add_group(\"agent\", \"uvmgr.cli.commands.agent\")\n _add_group(\"ap-scheduler\", \"uvmgr.cli.commands.ap_scheduler\")\n-\n-# --------------------------------------------------------------------------- #\n-# Legacy demo command (kept for fun; hidden from --help)\n-# --------------------------------------------------------------------------- #\n-@app.command(hidden=True)\n-def fire(name: str = \"Chell\") -> None:\n-    \"\"\"Fire the *portal gun* (demo command).\"\"\"\n-    colour(f\"[bold red]Alert![/bold red] {name} fired [green]portal gun[/green] :boom:\")\n-\n"
                },
                {
                    "date": 1748237388210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,38 +1,41 @@\n \"\"\"\n uvmgr.cli\n =========\n+Root Typer application.  Responsibilities:\n \n-Root Typer application – entry-point for the **uvmgr** console script.\n-\n-* 100 % helper–compliant (Rich colours, OpenTelemetry spans).\n-* No generic “run” verb – every activity gets a first-class sub-command.\n+* Global JSON flag (`--json / -j`)\n+* Logging bootstrap (rich colours + OpenTelemetry spans)\n+* Lazy-mount every sub-command in `uvmgr.cli.commands`\n \"\"\"\n \n from __future__ import annotations\n \n import importlib\n-import logging\n+import sys\n+from typing import List\n \n import typer\n \n from uvmgr.core.shell import colour, dump_json\n from uvmgr.core.telemetry import setup_logging\n \n-# --------------------------------------------------------------------------- #\n-# Logging / Rich initialisation\n-# --------------------------------------------------------------------------- #\n+# ──────────────────────────────────────────────────────────────────────────────\n+# Bootstrap logging once\n+# ──────────────────────────────────────────────────────────────────────────────\n setup_logging(\"INFO\")\n-_log = logging.getLogger(\"uvmgr.cli\")\n \n # --------------------------------------------------------------------------- #\n # Root Typer app\n # --------------------------------------------------------------------------- #\n-app = typer.Typer(add_completion=False, rich_markup_mode=\"rich\")\n+app = typer.Typer(\n+    add_completion=False,\n+    rich_markup_mode=\"rich\",\n+    help=\"**uvmgr** – unified Python workflow engine (powered by *uv*).\",\n+)\n \n-\n-def _json_flag(ctx: typer.Context, _: bool):\n-    \"\"\"Mark this ctx so sub-commands can dump JSON and exit early.\"\"\"\n+# Store JSON preference in ctx.meta so every sub-command can honour it\n+def _json_cb(ctx: typer.Context, _: bool):\n     ctx.meta[\"json\"] = True\n \n \n @app.callback()\n@@ -41,50 +44,41 @@\n     json_: bool = typer.Option(\n         False,\n         \"--json\",\n         \"-j\",\n+        callback=_json_cb,\n+        is_eager=True,\n         help=\"Print machine-readable JSON and exit\",\n-        callback=_json_flag,\n-        is_eager=True,\n     ),\n ):\n-    \"\"\"**uvmgr** – unified Python workflow engine (powered by *uv*).\"\"\"\n+    ...\n \n \n-# Helper used by mounts below -------------------------------------------------\n-def _add_group(name: str, module_path: str, attr: str = \"app\"):\n-    \"\"\"\n-    Import *module_path* and mount its Typer sub-app as **name**.\n+def maybe_json(ctx: typer.Context, payload):\n+    \"\"\"Utility for sub-commands: print JSON and exit if --json was given.\"\"\"\n+    if ctx.meta.get(\"json\"):\n+        dump_json(payload)\n+        raise typer.Exit()\n \n-    Silently ignores optional verbs that aren’t installed yet (e.g. ai extras).\n-    \"\"\"\n-    try:\n-        sub_app = getattr(importlib.import_module(module_path), attr)\n-    except ModuleNotFoundError as exc:\n-        _log.debug(\"Optional command group '%s' skipped (%s)\", name, exc)\n-        return\n-    app.add_typer(sub_app, name=name)\n \n-\n # --------------------------------------------------------------------------- #\n-# Mount all command groups\n+# Mount all command groups dynamically\n # --------------------------------------------------------------------------- #\n-_add_group(\"new\", \"uvmgr.cli.commands.project\")        # uvmgr new\n-_add_group(\"deps\", \"uvmgr.cli.commands.deps\")          # uvmgr deps …\n-_add_group(\"lint\", \"uvmgr.cli.commands.dev\")\n-_add_group(\"test\", \"uvmgr.cli.commands.dev\")\n-_add_group(\"serve\", \"uvmgr.cli.commands.dev\")\n+from uvmgr.cli import commands  # noqa: E402  (after app defined)\n \n-_add_group(\"exec\", \"uvmgr.cli.commands.exec\")\n-_add_group(\"task\", \"uvmgr.cli.commands.task\")\n-_add_group(\"shell\", \"uvmgr.cli.commands.shell\")\n-_add_group(\"build\", \"uvmgr.cli.commands.build\")\n-_add_group(\"release\", \"uvmgr.cli.commands.release\")\n-\n-_add_group(\"tool\", \"uvmgr.cli.commands.tool\")\n-_add_group(\"cache\", \"uvmgr.cli.commands.cache\")\n-_add_group(\"index\", \"uvmgr.cli.commands.index\")\n-\n-_add_group(\"ai\", \"uvmgr.cli.commands.ai\")              # optional DSPy extras\n-_add_group(\"remote\", \"uvmgr.cli.commands.remote\")\n-_add_group(\"agent\", \"uvmgr.cli.commands.agent\")\n-_add_group(\"ap-scheduler\", \"uvmgr.cli.commands.ap_scheduler\")\n+for mod_name in commands.__all__:\n+    mod = importlib.import_module(f\"uvmgr.cli.commands.{mod_name}\")\n+    # Each command module must expose a Typer sub-app named *_app* or\n+    # *{verb}_app* (e.g. deps_app, build_app).  We introspect for the first\n+    # Typer object in its globals.\n+    sub_app = next(\n+        (\n+            obj\n+            for obj in mod.__dict__.values()\n+            if isinstance(obj, typer.Typer)\n+        ),\n+        None,\n+    )\n+    if sub_app is None:\n+        # Fail fast during development\n+        raise ImportError(f\"{mod_name} has no Typer sub-app\")\n+    app.add_typer(sub_app, name=mod_name.replace(\"_\", \"-\"))\n"
                },
                {
                    "date": 1748237460050,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,9 +62,10 @@\n \n # --------------------------------------------------------------------------- #\n # Mount all command groups dynamically\n # --------------------------------------------------------------------------- #\n-from uvmgr.cli import commands  # noqa: E402  (after app defined)\n+import importlib\n+commands = importlib.import_module(\"uvmgr.cli.commands\")  # ← no circular import\n \n for mod_name in commands.__all__:\n     mod = importlib.import_module(f\"uvmgr.cli.commands.{mod_name}\")\n     # Each command module must expose a Typer sub-app named *_app* or\n"
                },
                {
                    "date": 1748237715964,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,85 @@\n+\"\"\"\n+uvmgr.cli\n+=========\n+\n+Root Typer application.\n+\n+• Sets up logging once (plain `logging` + optional OpenTelemetry)\n+• Adds a global `--json / -j` flag\n+• Dynamically mounts every sub-command package found in **uvmgr.commands**\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import importlib\n+import sys\n+from pathlib import Path\n+from typing import Any\n+\n+import typer\n+\n+from uvmgr.core.shell import colour, dump_json\n+from uvmgr.core.telemetry import setup_logging\n+\n+# ──────────────────────────────────────────────────────────────────────────────\n+#  Logging bootstrap (idempotent)\n+# ──────────────────────────────────────────────────────────────────────────────\n+setup_logging(\"INFO\")\n+\n+# ──────────────────────────────────────────────────────────────────────────────\n+#  Root Typer application\n+# ──────────────────────────────────────────────────────────────────────────────\n+app = typer.Typer(\n+    add_completion=False,\n+    rich_markup_mode=\"rich\",\n+    help=\"**uvmgr** – unified Python workflow engine (powered by *uv*).\",\n+)\n+\n+# Record JSON preference in ctx.meta so sub-commands can honour it -------------\n+def _json_cb(ctx: typer.Context, _: bool):  # noqa: D401\n+    ctx.meta[\"json\"] = True\n+\n+\n+@app.callback()\n+def _root(                              # noqa: D401\n+    ctx: typer.Context,\n+    json_: bool = typer.Option(\n+        False,\n+        \"--json\",\n+        \"-j\",\n+        callback=_json_cb,\n+        is_eager=True,\n+        help=\"Print machine-readable JSON and exit\",\n+    ),\n+):\n+    \"\"\"Callback only sets the JSON flag – no other side-effects.\"\"\"\n+\n+\n+def maybe_json(ctx: typer.Context, payload: Any) -> None:\n+    \"\"\"\n+    Utility: in sub-commands call **maybe_json(ctx, data)**; if the user\n+    passed --json we dump the object and exit early.\n+    \"\"\"\n+    if ctx.meta.get(\"json\"):\n+        dump_json(payload)\n+        raise typer.Exit()\n+\n+\n+# ──────────────────────────────────────────────────────────────────────────────\n+#  Mount every sub-command defined in *uvmgr.commands*\n+# ──────────────────────────────────────────────────────────────────────────────\n+commands_pkg = importlib.import_module(\"uvmgr.commands\")\n+\n+for verb in commands_pkg.__all__:\n+    mod = importlib.import_module(f\"uvmgr.commands.{verb}\")\n+\n+    # Expect exactly one typer.Typer object in the module’s globals ------------\n+    sub_app = next(\n+        (obj for obj in mod.__dict__.values() if isinstance(obj, typer.Typer)),\n+        None,\n+    )\n+    if sub_app is None:  # Fail fast during development\n+        raise ImportError(f\"`{verb}` has no Typer sub-app\")\n+\n+    # Mount under the same name (convert _ to - for nicer CLI UX) --------------\n+    app.add_typer(sub_app, name=verb.replace(\"_\", \"-\"))\n"
                },
                {
                    "date": 1748241838060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,89 +82,5 @@\n         raise ImportError(f\"`{verb}` has no Typer sub-app\")\n \n     # Mount under the same name (convert _ to - for nicer CLI UX) --------------\n     app.add_typer(sub_app, name=verb.replace(\"_\", \"-\"))\n-\"\"\"\n-uvmgr.cli\n-=========\n-Root Typer application.  Responsibilities:\n \n-* Global JSON flag (`--json / -j`)\n-* Logging bootstrap (rich colours + OpenTelemetry spans)\n-* Lazy-mount every sub-command in `uvmgr.cli.commands`\n-\"\"\"\n-\n-from __future__ import annotations\n-\n-import importlib\n-import sys\n-from typing import List\n-\n-import typer\n-\n-from uvmgr.core.shell import colour, dump_json\n-from uvmgr.core.telemetry import setup_logging\n-\n-# ──────────────────────────────────────────────────────────────────────────────\n-# Bootstrap logging once\n-# ──────────────────────────────────────────────────────────────────────────────\n-setup_logging(\"INFO\")\n-\n-# --------------------------------------------------------------------------- #\n-# Root Typer app\n-# --------------------------------------------------------------------------- #\n-app = typer.Typer(\n-    add_completion=False,\n-    rich_markup_mode=\"rich\",\n-    help=\"**uvmgr** – unified Python workflow engine (powered by *uv*).\",\n-)\n-\n-# Store JSON preference in ctx.meta so every sub-command can honour it\n-def _json_cb(ctx: typer.Context, _: bool):\n-    ctx.meta[\"json\"] = True\n-\n-\n-@app.callback()\n-def _root(\n-    ctx: typer.Context,\n-    json_: bool = typer.Option(\n-        False,\n-        \"--json\",\n-        \"-j\",\n-        callback=_json_cb,\n-        is_eager=True,\n-        help=\"Print machine-readable JSON and exit\",\n-    ),\n-):\n-    ...\n-\n-\n-def maybe_json(ctx: typer.Context, payload):\n-    \"\"\"Utility for sub-commands: print JSON and exit if --json was given.\"\"\"\n-    if ctx.meta.get(\"json\"):\n-        dump_json(payload)\n-        raise typer.Exit()\n-\n-\n-# --------------------------------------------------------------------------- #\n-# Mount all command groups dynamically\n-# --------------------------------------------------------------------------- #\n-import importlib\n-commands = importlib.import_module(\"uvmgr.cli.commands\")  # ← no circular import\n-\n-for mod_name in commands.__all__:\n-    mod = importlib.import_module(f\"uvmgr.cli.commands.{mod_name}\")\n-    # Each command module must expose a Typer sub-app named *_app* or\n-    # *{verb}_app* (e.g. deps_app, build_app).  We introspect for the first\n-    # Typer object in its globals.\n-    sub_app = next(\n-        (\n-            obj\n-            for obj in mod.__dict__.values()\n-            if isinstance(obj, typer.Typer)\n-        ),\n-        None,\n-    )\n-    if sub_app is None:\n-        # Fail fast during development\n-        raise ImportError(f\"{mod_name} has no Typer sub-app\")\n-    app.add_typer(sub_app, name=mod_name.replace(\"_\", \"-\"))\n"
                },
                {
                    "date": 1748241843312,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,8 +20,12 @@\n \n from uvmgr.core.shell import colour, dump_json\n from uvmgr.core.telemetry import setup_logging\n \n+\n++import os\n++os.environ.setdefault(\"LITELLM_LOCAL_MODEL_COST_MAP\", \"True\")\n+\n # ──────────────────────────────────────────────────────────────────────────────\n #  Logging bootstrap (idempotent)\n # ──────────────────────────────────────────────────────────────────────────────\n setup_logging(\"INFO\")\n"
                },
                {
                    "date": 1748245610156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,12 +20,11 @@\n \n from uvmgr.core.shell import colour, dump_json\n from uvmgr.core.telemetry import setup_logging\n \n+import os\n+os.environ.setdefault(\"LITELLM_LOCAL_MODEL_COST_MAP\", \"True\")\n \n-+import os\n-+os.environ.setdefault(\"LITELLM_LOCAL_MODEL_COST_MAP\", \"True\")\n-\n # ──────────────────────────────────────────────────────────────────────────────\n #  Logging bootstrap (idempotent)\n # ──────────────────────────────────────────────────────────────────────────────\n setup_logging(\"INFO\")\n@@ -40,9 +39,11 @@\n )\n \n # Record JSON preference in ctx.meta so sub-commands can honour it -------------\n def _json_cb(ctx: typer.Context, _: bool):  # noqa: D401\n+    print(\"DEBUG _json_cb called. ctx.meta before:\", ctx.meta)\n     ctx.meta[\"json\"] = True\n+    print(\"DEBUG _json_cb called. ctx.meta after:\", ctx.meta)\n \n \n @app.callback()\n def _root(                              # noqa: D401\n@@ -76,9 +77,9 @@\n \n for verb in commands_pkg.__all__:\n     mod = importlib.import_module(f\"uvmgr.commands.{verb}\")\n \n-    # Expect exactly one typer.Typer object in the module’s globals ------------\n+    # Expect exactly one typer.Typer object in the module's globals ------------\n     sub_app = next(\n         (obj for obj in mod.__dict__.values() if isinstance(obj, typer.Typer)),\n         None,\n     )\n"
                },
                {
                    "date": 1748245628932,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,91 @@\n+\"\"\"\n+uvmgr.cli\n+=========\n+\n+Root Typer application.\n+\n+• Sets up logging once (plain `logging` + optional OpenTelemetry)\n+• Adds a global `--json / -j` flag\n+• Dynamically mounts every sub-command package found in **uvmgr.commands**\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import importlib\n+import sys\n+from pathlib import Path\n+from typing import Any\n+\n+import typer\n+\n+from uvmgr.core.shell import colour, dump_json\n+from uvmgr.core.telemetry import setup_logging\n+\n+import os\n+os.environ.setdefault(\"LITELLM_LOCAL_MODEL_COST_MAP\", \"True\")\n+\n+# ──────────────────────────────────────────────────────────────────────────────\n+#  Logging bootstrap (idempotent)\n+# ──────────────────────────────────────────────────────────────────────────────\n+setup_logging(\"INFO\")\n+\n+# ──────────────────────────────────────────────────────────────────────────────\n+#  Root Typer application\n+# ──────────────────────────────────────────────────────────────────────────────\n+app = typer.Typer(\n+    add_completion=False,\n+    rich_markup_mode=\"rich\",\n+    help=\"**uvmgr** – unified Python workflow engine (powered by *uv*).\",\n+)\n+\n+# Record JSON preference in ctx.meta so sub-commands can honour it -------------\n+def _json_cb(ctx: typer.Context, _: bool):  # noqa: D401\n+    print(\"DEBUG _json_cb called. ctx.meta before:\", ctx.meta)\n+    ctx.meta[\"json\"] = True\n+    print(\"DEBUG _json_cb called. ctx.meta after:\", ctx.meta)\n+\n+\n+@app.callback()\n+def _root(                              # noqa: D401\n+    ctx: typer.Context,\n+    json_: bool = typer.Option(\n+        False,\n+        \"--json\",\n+        \"-j\",\n+        callback=_json_cb,\n+        is_eager=True,\n+        help=\"Print machine-readable JSON and exit\",\n+    ),\n+):\n+    \"\"\"Callback only sets the JSON flag – no other side-effects.\"\"\"\n+\n+\n+def maybe_json(ctx: typer.Context, payload: Any) -> None:\n+    \"\"\"\n+    Utility: in sub-commands call **maybe_json(ctx, data)**; if the user\n+    passed --json we dump the object and exit early.\n+    \"\"\"\n+    if ctx.meta.get(\"json\"):\n+        dump_json(payload)\n+        raise typer.Exit()\n+\n+\n+# ──────────────────────────────────────────────────────────────────────────────\n+#  Mount every sub-command defined in *uvmgr.commands*\n+# ──────────────────────────────────────────────────────────────────────────────\n+commands_pkg = importlib.import_module(\"uvmgr.commands\")\n+\n+for verb in commands_pkg.__all__:\n+    mod = importlib.import_module(f\"uvmgr.commands.{verb}\")\n+\n+    # Expect exactly one typer.Typer object in the module's globals ------------\n+    sub_app = next(\n+        (obj for obj in mod.__dict__.values() if isinstance(obj, typer.Typer)),\n+        None,\n+    )\n+    if sub_app is None:  # Fail fast during development\n+        raise ImportError(f\"`{verb}` has no Typer sub-app\")\n+\n+    # Mount under the same name (convert _ to - for nicer CLI UX) --------------\n+    app.add_typer(sub_app, name=verb.replace(\"_\", \"-\"))\n+\n"
                },
                {
                    "date": 1748245651528,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,12 +38,13 @@\n     help=\"**uvmgr** – unified Python workflow engine (powered by *uv*).\",\n )\n \n # Record JSON preference in ctx.meta so sub-commands can honour it -------------\n-def _json_cb(ctx: typer.Context, _: bool):  # noqa: D401\n-    print(\"DEBUG _json_cb called. ctx.meta before:\", ctx.meta)\n-    ctx.meta[\"json\"] = True\n-    print(\"DEBUG _json_cb called. ctx.meta after:\", ctx.meta)\n+def _json_cb(ctx: typer.Context, value: bool):  # noqa: D401\n+    print(\"DEBUG _json_cb called. ctx.meta before:\", ctx.meta, \"value:\", value)\n+    if value:\n+        ctx.meta[\"json\"] = True\n+        print(\"DEBUG _json_cb called. ctx.meta after:\", ctx.meta)\n \n \n @app.callback()\n def _root(                              # noqa: D401\n@@ -88,95 +89,4 @@\n \n     # Mount under the same name (convert _ to - for nicer CLI UX) --------------\n     app.add_typer(sub_app, name=verb.replace(\"_\", \"-\"))\n \n-\"\"\"\n-uvmgr.cli\n-=========\n-\n-Root Typer application.\n-\n-• Sets up logging once (plain `logging` + optional OpenTelemetry)\n-• Adds a global `--json / -j` flag\n-• Dynamically mounts every sub-command package found in **uvmgr.commands**\n-\"\"\"\n-\n-from __future__ import annotations\n-\n-import importlib\n-import sys\n-from pathlib import Path\n-from typing import Any\n-\n-import typer\n-\n-from uvmgr.core.shell import colour, dump_json\n-from uvmgr.core.telemetry import setup_logging\n-\n-import os\n-os.environ.setdefault(\"LITELLM_LOCAL_MODEL_COST_MAP\", \"True\")\n-\n-# ──────────────────────────────────────────────────────────────────────────────\n-#  Logging bootstrap (idempotent)\n-# ──────────────────────────────────────────────────────────────────────────────\n-setup_logging(\"INFO\")\n-\n-# ──────────────────────────────────────────────────────────────────────────────\n-#  Root Typer application\n-# ──────────────────────────────────────────────────────────────────────────────\n-app = typer.Typer(\n-    add_completion=False,\n-    rich_markup_mode=\"rich\",\n-    help=\"**uvmgr** – unified Python workflow engine (powered by *uv*).\",\n-)\n-\n-# Record JSON preference in ctx.meta so sub-commands can honour it -------------\n-def _json_cb(ctx: typer.Context, _: bool):  # noqa: D401\n-    print(\"DEBUG _json_cb called. ctx.meta before:\", ctx.meta)\n-    ctx.meta[\"json\"] = True\n-    print(\"DEBUG _json_cb called. ctx.meta after:\", ctx.meta)\n-\n-\n-@app.callback()\n-def _root(                              # noqa: D401\n-    ctx: typer.Context,\n-    json_: bool = typer.Option(\n-        False,\n-        \"--json\",\n-        \"-j\",\n-        callback=_json_cb,\n-        is_eager=True,\n-        help=\"Print machine-readable JSON and exit\",\n-    ),\n-):\n-    \"\"\"Callback only sets the JSON flag – no other side-effects.\"\"\"\n-\n-\n-def maybe_json(ctx: typer.Context, payload: Any) -> None:\n-    \"\"\"\n-    Utility: in sub-commands call **maybe_json(ctx, data)**; if the user\n-    passed --json we dump the object and exit early.\n-    \"\"\"\n-    if ctx.meta.get(\"json\"):\n-        dump_json(payload)\n-        raise typer.Exit()\n-\n-\n-# ──────────────────────────────────────────────────────────────────────────────\n-#  Mount every sub-command defined in *uvmgr.commands*\n-# ──────────────────────────────────────────────────────────────────────────────\n-commands_pkg = importlib.import_module(\"uvmgr.commands\")\n-\n-for verb in commands_pkg.__all__:\n-    mod = importlib.import_module(f\"uvmgr.commands.{verb}\")\n-\n-    # Expect exactly one typer.Typer object in the module's globals ------------\n-    sub_app = next(\n-        (obj for obj in mod.__dict__.values() if isinstance(obj, typer.Typer)),\n-        None,\n-    )\n-    if sub_app is None:  # Fail fast during development\n-        raise ImportError(f\"`{verb}` has no Typer sub-app\")\n-\n-    # Mount under the same name (convert _ to - for nicer CLI UX) --------------\n-    app.add_typer(sub_app, name=verb.replace(\"_\", \"-\"))\n-\n"
                },
                {
                    "date": 1748245723773,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,12 +39,10 @@\n )\n \n # Record JSON preference in ctx.meta so sub-commands can honour it -------------\n def _json_cb(ctx: typer.Context, value: bool):  # noqa: D401\n-    print(\"DEBUG _json_cb called. ctx.meta before:\", ctx.meta, \"value:\", value)\n     if value:\n         ctx.meta[\"json\"] = True\n-        print(\"DEBUG _json_cb called. ctx.meta after:\", ctx.meta)\n \n \n @app.callback()\n def _root(                              # noqa: D401\n"
                }
            ],
            "date": 1748231582166,
            "name": "Commit-0",
            "content": "\"\"\"\nuvmgr.cli\n=========\n\nRoot Typer application – entry-point for the **uvmgr** console script.\n\n* 100 % helper–compliant (Rich colours, OpenTelemetry spans).\n* No generic “run” verb – every activity gets a first-class sub-command.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport importlib\nimport logging\n\nimport typer\n\nfrom uvmgr.core.shell import colour, dump_json\nfrom uvmgr.core.telemetry import setup_logging\n\n# --------------------------------------------------------------------------- #\n# Logging / Rich initialisation\n# --------------------------------------------------------------------------- #\nsetup_logging(\"INFO\")\n_log = logging.getLogger(\"uvmgr.cli\")\n\n# --------------------------------------------------------------------------- #\n# Root Typer app\n# --------------------------------------------------------------------------- #\napp = typer.Typer(add_completion=False, rich_markup_mode=\"rich\")\n\n\ndef _json_flag(ctx: typer.Context, _: bool):\n    \"\"\"Mark this ctx so sub-commands can dump JSON and exit early.\"\"\"\n    ctx.meta[\"json\"] = True\n\n\n@app.callback()\ndef _root(\n    ctx: typer.Context,\n    json_: bool = typer.Option(\n        False,\n        \"--json\",\n        \"-j\",\n        help=\"Print machine-readable JSON and exit\",\n        callback=_json_flag,\n        is_eager=True,\n    ),\n):\n    \"\"\"**uvmgr** – unified Python workflow engine (powered by *uv*).\"\"\"\n\n\n# Helper used by mounts below -------------------------------------------------\ndef _add_group(name: str, module_path: str, attr: str = \"app\"):\n    \"\"\"\n    Import *module_path* and mount its Typer sub-app as **name**.\n\n    Silently ignores optional verbs that aren’t installed yet (e.g. ai extras).\n    \"\"\"\n    try:\n        sub_app = getattr(importlib.import_module(module_path), attr)\n    except ModuleNotFoundError as exc:\n        _log.debug(\"Optional command group '%s' skipped (%s)\", name, exc)\n        return\n    app.add_typer(sub_app, name=name)\n\n\n# --------------------------------------------------------------------------- #\n# Mount all command groups\n# --------------------------------------------------------------------------- #\n_add_group(\"new\", \"uvmgr.cli.commands.project\")        # uvmgr new\n_add_group(\"deps\", \"uvmgr.cli.commands.deps\")          # uvmgr deps …\n_add_group(\"lint\", \"uvmgr.cli.commands.dev\")\n_add_group(\"test\", \"uvmgr.cli.commands.dev\")\n_add_group(\"serve\", \"uvmgr.cli.commands.dev\")\n\n_add_group(\"exec\", \"uvmgr.cli.commands.exec\")\n_add_group(\"task\", \"uvmgr.cli.commands.task\")\n_add_group(\"shell\", \"uvmgr.cli.commands.shell\")\n_add_group(\"build\", \"uvmgr.cli.commands.build\")\n_add_group(\"release\", \"uvmgr.cli.commands.release\")\n\n_add_group(\"tool\", \"uvmgr.cli.commands.tool\")\n_add_group(\"cache\", \"uvmgr.cli.commands.cache\")\n_add_group(\"index\", \"uvmgr.cli.commands.index\")\n\n_add_group(\"ai\", \"uvmgr.cli.commands.ai\")              # optional DSPy extras\n_add_group(\"remote\", \"uvmgr.cli.commands.remote\")\n_add_group(\"agent\", \"uvmgr.cli.commands.agent\")\n_add_group(\"ap-scheduler\", \"uvmgr.cli.commands.ap_scheduler\")\n\n# --------------------------------------------------------------------------- #\n# Legacy demo command (kept for fun; hidden from --help)\n# --------------------------------------------------------------------------- #\n@app.command(hidden=True)\ndef fire(name: str = \"Chell\") -> None:\n    \"\"\"Fire the *portal gun* (demo command).\"\"\"\n    colour(f\"[bold red]Alert![/bold red] {name} fired [green]portal gun[/green] :boom:\")\n\n"
        }
    ]
}
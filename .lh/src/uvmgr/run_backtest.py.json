{
    "sourceFile": "src/uvmgr/run_backtest.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1748366442256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1748366442256,
            "name": "Commit-0",
            "content": "#!/usr/bin/env python3\n\"\"\"Run a NautilusTrader backtest with MACD strategy.\"\"\"\n\nimport asyncio\nimport logging\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom nautilus_trader.backtest.engine import BacktestEngine\nfrom nautilus_trader.backtest.node import (\n    BacktestDataConfig,\n    BacktestEngineConfig,\n    BacktestNode,\n    BacktestRunConfig,\n    BacktestVenueConfig,\n)\nfrom nautilus_trader.config import ImportableStrategyConfig, LoggingConfig\nfrom nautilus_trader.core.message import Event\nfrom nautilus_trader.indicators.macd import MovingAverageConvergenceDivergence\nfrom nautilus_trader.model import InstrumentId, Position, Quantity, QuoteTick, Venue\nfrom nautilus_trader.model.enums import OrderSide, PositionSide, PriceType\nfrom nautilus_trader.model.events import PositionOpened\nfrom nautilus_trader.persistence.catalog import ParquetDataCatalog\nfrom nautilus_trader.trading.strategy import Strategy, StrategyConfig\n\n\nclass MACDConfig(StrategyConfig):\n    \"\"\"Configuration for the MACD strategy.\"\"\"\n    \n    instrument_id: InstrumentId\n    fast_period: int = 12\n    slow_period: int = 26\n    trade_size: int = 1_000_000\n    entry_threshold: float = 0.00010\n\n\nclass MACDStrategy(Strategy):\n    \"\"\"A simple MACD-based trading strategy.\"\"\"\n    \n    def __init__(self, config: MACDConfig):\n        super().__init__(config=config)\n        self.macd = MovingAverageConvergenceDivergence(\n            fast_period=config.fast_period,\n            slow_period=config.slow_period,\n            price_type=PriceType.MID,\n        )\n        self.trade_size = Quantity.from_int(config.trade_size)\n        self.position: Position | None = None\n        self._logger = logging.getLogger(__name__)\n\n    def on_start(self):\n        \"\"\"Actions to be performed on strategy start.\"\"\"\n        self.subscribe_quote_ticks(instrument_id=self.config.instrument_id)\n        self._logger.info(\"Strategy started\")\n\n    def on_stop(self):\n        \"\"\"Actions to be performed on strategy stop.\"\"\"\n        self.close_all_positions(self.config.instrument_id)\n        self.unsubscribe_quote_ticks(instrument_id=self.config.instrument_id)\n        self._logger.info(\"Strategy stopped\")\n\n    def on_quote_tick(self, tick: QuoteTick):\n        \"\"\"Actions to be performed on receiving a quote tick.\"\"\"\n        self.macd.handle_quote_tick(tick)\n\n        if not self.macd.initialized:\n            return\n\n        self.check_for_entry()\n        self.check_for_exit()\n\n    def on_event(self, event: Event):\n        \"\"\"Actions to be performed on receiving an event.\"\"\"\n        if isinstance(event, PositionOpened):\n            self.position = self.cache.position(event.position_id)\n            self._logger.info(f\"Position opened: {self.position}\")\n\n    def check_for_entry(self):\n        \"\"\"Check for entry conditions and submit orders if met.\"\"\"\n        if self.macd.value > self.config.entry_threshold:\n            if self.position and self.position.side == PositionSide.LONG:\n                return\n\n            order = self.order_factory.market(\n                instrument_id=self.config.instrument_id,\n                order_side=OrderSide.BUY,\n                quantity=self.trade_size,\n            )\n            self.submit_order(order)\n            self._logger.info(\"Submitted BUY order\")\n        elif self.macd.value < -self.config.entry_threshold:\n            if self.position and self.position.side == PositionSide.SHORT:\n                return\n\n            order = self.order_factory.market(\n                instrument_id=self.config.instrument_id,\n                order_side=OrderSide.SELL,\n                quantity=self.trade_size,\n            )\n            self.submit_order(order)\n            self._logger.info(\"Submitted SELL order\")\n\n    def check_for_exit(self):\n        \"\"\"Check for exit conditions and close positions if met.\"\"\"\n        if self.macd.value >= 0.0:\n            if self.position and self.position.side == PositionSide.SHORT:\n                self.close_position(self.position)\n                self._logger.info(\"Closed SHORT position\")\n        else:\n            if self.position and self.position.side == PositionSide.LONG:\n                self.close_position(self.position)\n                self._logger.info(\"Closed LONG position\")\n\n\nasync def run_backtest(\n    catalog_path: str,\n    instrument_id: str,\n    start_time: datetime | None = None,\n    end_time: datetime | None = None,\n    log_level: str = \"INFO\",\n) -> BacktestEngine:\n    \"\"\"\n    Run a backtest with the MACD strategy.\n\n    Args:\n        catalog_path: Path to the Parquet data catalog\n        instrument_id: The instrument ID to trade\n        start_time: Optional start time for the backtest\n        end_time: Optional end time for the backtest\n        log_level: Logging level for the backtest\n\n    Returns:\n        The backtest engine instance containing the results\n    \"\"\"\n    # Configure logging\n    logging.basicConfig(\n        level=getattr(logging, log_level),\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    )\n    logger = logging.getLogger(__name__)\n\n    try:\n        # Load data catalog\n        catalog = ParquetDataCatalog(catalog_path)\n        instruments = catalog.instruments()\n        \n        if not instruments:\n            raise ValueError(\"No instruments found in catalog\")\n\n        # Find the requested instrument\n        instrument = next((i for i in instruments if str(i.id) == instrument_id), None)\n        if not instrument:\n            raise ValueError(f\"Instrument {instrument_id} not found in catalog\")\n\n        # Configure venue\n        venue = BacktestVenueConfig(\n            name=\"SIM\",\n            oms_type=\"NETTING\",\n            account_type=\"MARGIN\",\n            base_currency=\"USD\",\n            starting_balances=[\"1_000_000 USD\"],\n        )\n\n        # Configure data\n        data = BacktestDataConfig(\n            catalog_path=str(catalog.path),\n            data_cls=QuoteTick,\n            instrument_id=instrument.id,\n            start_time=start_time,\n            end_time=end_time,\n        )\n\n        # Configure engine\n        engine = BacktestEngineConfig(\n            strategies=[\n                ImportableStrategyConfig(\n                    strategy_path=\"__main__:MACDStrategy\",\n                    config_path=\"__main__:MACDConfig\",\n                    config={\n                        \"instrument_id\": instrument.id,\n                        \"fast_period\": 12,\n                        \"slow_period\": 26,\n                    },\n                )\n            ],\n            logging=LoggingConfig(log_level=log_level),\n        )\n\n        # Configure and run backtest\n        config = BacktestRunConfig(\n            engine=engine,\n            venues=[venue],\n            data=[data],\n        )\n\n        node = BacktestNode(configs=[config])\n        results = node.run()\n\n        if not results:\n            raise RuntimeError(\"Backtest produced no results\")\n\n        # Get the engine for analysis\n        engine = node.get_engine(config.id)\n        \n        # Generate reports\n        logger.info(\"\\nOrder Fills Report:\")\n        logger.info(engine.trader.generate_order_fills_report())\n        \n        logger.info(\"\\nPositions Report:\")\n        logger.info(engine.trader.generate_positions_report())\n        \n        logger.info(\"\\nAccount Report:\")\n        logger.info(engine.trader.generate_account_report(Venue(\"SIM\")))\n\n        return engine\n\n    except Exception as e:\n        logger.error(f\"Error running backtest: {e}\", exc_info=True)\n        raise\n\n\ndef main():\n    \"\"\"Run the backtest with sample data.\"\"\"\n    # Run the backtest with sample data\n    asyncio.run(\n        run_backtest(\n            catalog_path=\"./catalog\",\n            instrument_id=\"EUR/USD.SIM\",\n            start_time=datetime(2020, 1, 1),\n            end_time=datetime(2020, 1, 10),\n            log_level=\"INFO\",\n        )\n    )\n\n\nif __name__ == \"__main__\":\n    main() "
        }
    ]
}
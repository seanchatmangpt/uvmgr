{
    "sourceFile": "src/uvmgr/runtime/uv.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1748231745841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1748231752813,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,44 @@\n+\"\"\"\n+uvmgr.ops.deps\n+--------------\n+User-facing dependency orchestration (no subprocess here).\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import json\n+import logging\n+from pathlib import Path\n+from typing import List\n+\n+from uvmgr.core.shell import timed\n+from uvmgr.core.telemetry import span\n+from uvmgr.runtime import uv as _rt\n+\n+_log = logging.getLogger(\"uvmgr.ops.deps\")\n+\n+\n+@timed\n+def add(pkgs: List[str], *, dev: bool = False) -> dict:\n+    with span(\"deps.add\", pkgs=\" \".join(pkgs), dev=dev):\n+        _rt.add(pkgs, dev=dev)\n+    return {\"added\": pkgs, \"dev\": dev}\n+\n+\n+@timed\n+def remove(pkgs: List[str]) -> dict:\n+    with span(\"deps.remove\", pkgs=\" \".join(pkgs)):\n+        _rt.remove(pkgs)\n+    return {\"removed\": pkgs}\n+\n+\n+@timed\n+def upgrade(all_pkgs: bool = False, pkgs: List[str] | None = None) -> dict:\n+    with span(\"deps.upgrade\", all=all_pkgs, pkgs=pkgs):\n+        _rt.upgrade(all_pkgs=all_pkgs, pkgs=pkgs)\n+    return {\"upgraded\": \"all\" if all_pkgs else pkgs}\n+\n+\n+def list_pkgs() -> list[str]:\n+    txt = _rt.list_pkgs()\n+    return txt.splitlines()\n"
                },
                {
                    "date": 1748231856260,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,15 +1,13 @@\n \"\"\"\n uvmgr.ops.deps\n --------------\n-User-facing dependency orchestration (no subprocess here).\n+User-facing dependency orchestration (uv add / remove / upgrade / list).\n \"\"\"\n \n from __future__ import annotations\n \n-import json\n import logging\n-from pathlib import Path\n from typing import List\n \n from uvmgr.core.shell import timed\n from uvmgr.core.telemetry import span\n@@ -21,45 +19,29 @@\n @timed\n def add(pkgs: List[str], *, dev: bool = False) -> dict:\n     with span(\"deps.add\", pkgs=\" \".join(pkgs), dev=dev):\n         _rt.add(pkgs, dev=dev)\n+    _log.debug(\"Added %s (dev=%s)\", pkgs, dev)\n     return {\"added\": pkgs, \"dev\": dev}\n \n \n @timed\n def remove(pkgs: List[str]) -> dict:\n     with span(\"deps.remove\", pkgs=\" \".join(pkgs)):\n         _rt.remove(pkgs)\n+    _log.debug(\"Removed %s\", pkgs)\n     return {\"removed\": pkgs}\n \n \n @timed\n-def upgrade(all_pkgs: bool = False, pkgs: List[str] | None = None) -> dict:\n+def upgrade(*, all_pkgs: bool = False, pkgs: List[str] | None = None) -> dict:\n     with span(\"deps.upgrade\", all=all_pkgs, pkgs=pkgs):\n         _rt.upgrade(all_pkgs=all_pkgs, pkgs=pkgs)\n+    _log.debug(\"Upgraded %s\", \"all packages\" if all_pkgs else pkgs)\n     return {\"upgraded\": \"all\" if all_pkgs else pkgs}\n \n \n def list_pkgs() -> list[str]:\n+    \"\"\"Return the current dependency list as plain strings.\"\"\"\n     txt = _rt.list_pkgs()\n+    _log.debug(\"Listed %d packages\", len(txt.splitlines()))\n     return txt.splitlines()\n-# --------------------------------------------------------------------------- #\n-# Higher-level helpers (used by ops.deps)                                     #\n-# --------------------------------------------------------------------------- #\n-def add(pkgs: list[str], *, dev: bool = False) -> None:\n-    flags = \"--dev\" if dev else \"\"\n-    call(f\"add {flags} {' '.join(pkgs)}\")\n-\n-\n-def remove(pkgs: list[str]) -> None:\n-    call(f\"remove {' '.join(pkgs)}\")\n-\n-\n-def upgrade(all_pkgs: bool = False, pkgs: list[str] | None = None) -> None:\n-    if all_pkgs:\n-        call(\"upgrade --all\")\n-    elif pkgs:\n-        call(f\"upgrade {' '.join(pkgs)}\")\n-\n-\n-def list_pkgs() -> str:\n-    return call(\"list\", capture=True) or \"\"\n"
                },
                {
                    "date": 1748234435628,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,87 @@\n+\"\"\"\n+uvmgr.runtime.uv\n+================\n+Thin, opinionated wrapper around the **uv** command-line tool.\n+\n+Responsibilities\n+----------------\n+* Build the final shell command (`[\"uv\", …]`) with global flags.\n+* Delegate execution to `core.process.run_logged`, which:\n+  – prints colourised `$ cmd`,\n+  – respects UVMGR_DRY / UVMGR_QUIET,\n+  – records an OpenTelemetry span.\n+* Offer convenience helpers (`add()`, `remove()`, …) used by `ops.deps`.\n+No business logic lives here – that belongs in the *ops* layer.\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import logging\n+import shlex\n+from pathlib import Path\n+from typing import List\n+\n+from uvmgr.core.process import run_logged\n+from uvmgr.core.telemetry import span\n+from uvmgr.core.shell import colour\n+from uvmgr.core.config import env_or\n+\n+_log = logging.getLogger(\"uvmgr.runtime.uv\")\n+\n+\n+# --------------------------------------------------------------------------- #\n+# Low-level executor\n+# --------------------------------------------------------------------------- #\n+def _extra_flags() -> list[str]:\n+    \"\"\"\n+    Compose global flags that should apply to **every** uv invocation\n+    (read from env vars so CI can tweak behaviour).\n+    \"\"\"\n+    flags: list[str] = []\n+    if env_or(\"UV_OFFLINE\") == \"1\":\n+        flags.append(\"--offline\")\n+    if url := env_or(\"UV_EXTRA_INDEX\"):\n+        flags += [\"--extra-index-url\", url]\n+    return flags\n+\n+\n+def call(sub_cmd: str, *, capture: bool = False, cwd: Path | None = None) -> str | None:\n+    \"\"\"\n+    Execute `uv <sub_cmd>` and return stdout if *capture* is True.\n+\n+    Examples\n+    --------\n+    >>> call(\"add fastapi ruff\")\n+    >>> text = call(\"list\", capture=True)\n+    \"\"\"\n+    cmd = [\"uv\"] + shlex.split(sub_cmd) + _extra_flags()\n+    _log.debug(\"uv call: %s\", cmd)\n+    with span(\"uv.call\", cmd=\" \".join(cmd)):\n+        return run_logged(cmd, capture=capture, cwd=cwd)\n+\n+\n+# --------------------------------------------------------------------------- #\n+# High-level helpers – used by ops.deps\n+# --------------------------------------------------------------------------- #\n+def add(pkgs: List[str], *, dev: bool = False) -> None:\n+    flags = \"--dev\" if dev else \"\"\n+    call(f\"add {flags} {' '.join(pkgs)}\")\n+\n+\n+def remove(pkgs: List[str]) -> None:\n+    call(f\"remove {' '.join(pkgs)}\")\n+\n+\n+def upgrade(*, all_pkgs: bool = False, pkgs: List[str] | None = None) -> None:\n+    if all_pkgs:\n+        call(\"upgrade --all\")\n+    elif pkgs:\n+        call(f\"upgrade {' '.join(pkgs)}\")\n+\n+\n+def list_pkgs() -> str:\n+    \"\"\"\n+    Return `uv list` output (one package per line) as **plain text**.\n+    The ops layer will turn it into a Python list.\n+    \"\"\"\n+    return call(\"list\", capture=True) or \"\"\n"
                },
                {
                    "date": 1748242247129,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,10 +50,10 @@\n     Execute `uv <sub_cmd>` and return stdout if *capture* is True.\n \n     Examples\n     --------\n-    >>> call(\"add fastapi ruff\")\n-    >>> text = call(\"list\", capture=True)\n+    >>> call(\"add fastapi ruff\")  # doctest: +ELLIPSIS\n+    $ uv add fastapi ruff\n     \"\"\"\n     cmd = [\"uv\"] + shlex.split(sub_cmd) + _extra_flags()\n     _log.debug(\"uv call: %s\", cmd)\n     with span(\"uv.call\", cmd=\" \".join(cmd)):\n"
                },
                {
                    "date": 1748244889346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,12 +20,12 @@\n import shlex\n from pathlib import Path\n from typing import List\n \n+from uvmgr.core.config import env_or\n from uvmgr.core.process import run_logged\n+from uvmgr.core.shell import colour\n from uvmgr.core.telemetry import span\n-from uvmgr.core.shell import colour\n-from uvmgr.core.config import env_or\n \n _log = logging.getLogger(\"uvmgr.runtime.uv\")\n \n \n@@ -62,18 +62,18 @@\n \n # --------------------------------------------------------------------------- #\n # High-level helpers – used by ops.deps\n # --------------------------------------------------------------------------- #\n-def add(pkgs: List[str], *, dev: bool = False) -> None:\n+def add(pkgs: list[str], *, dev: bool = False) -> None:\n     flags = \"--dev\" if dev else \"\"\n     call(f\"add {flags} {' '.join(pkgs)}\")\n \n \n-def remove(pkgs: List[str]) -> None:\n+def remove(pkgs: list[str]) -> None:\n     call(f\"remove {' '.join(pkgs)}\")\n \n \n-def upgrade(*, all_pkgs: bool = False, pkgs: List[str] | None = None) -> None:\n+def upgrade(*, all_pkgs: bool = False, pkgs: list[str] | None = None) -> None:\n     if all_pkgs:\n         call(\"upgrade --all\")\n     elif pkgs:\n         call(f\"upgrade {' '.join(pkgs)}\")\n@@ -84,51 +84,4 @@\n     Return `uv list` output (one package per line) as **plain text**.\n     The ops layer will turn it into a Python list.\n     \"\"\"\n     return call(\"list\", capture=True) or \"\"\n-\"\"\"\n-uvmgr.ops.deps\n---------------\n-User-facing dependency orchestration (uv add / remove / upgrade / list).\n-\"\"\"\n-\n-from __future__ import annotations\n-\n-import logging\n-from typing import List\n-\n-from uvmgr.core.shell import timed\n-from uvmgr.core.telemetry import span\n-from uvmgr.runtime import uv as _rt\n-\n-_log = logging.getLogger(\"uvmgr.ops.deps\")\n-\n-\n-@timed\n-def add(pkgs: List[str], *, dev: bool = False) -> dict:\n-    with span(\"deps.add\", pkgs=\" \".join(pkgs), dev=dev):\n-        _rt.add(pkgs, dev=dev)\n-    _log.debug(\"Added %s (dev=%s)\", pkgs, dev)\n-    return {\"added\": pkgs, \"dev\": dev}\n-\n-\n-@timed\n-def remove(pkgs: List[str]) -> dict:\n-    with span(\"deps.remove\", pkgs=\" \".join(pkgs)):\n-        _rt.remove(pkgs)\n-    _log.debug(\"Removed %s\", pkgs)\n-    return {\"removed\": pkgs}\n-\n-\n-@timed\n-def upgrade(*, all_pkgs: bool = False, pkgs: List[str] | None = None) -> dict:\n-    with span(\"deps.upgrade\", all=all_pkgs, pkgs=pkgs):\n-        _rt.upgrade(all_pkgs=all_pkgs, pkgs=pkgs)\n-    _log.debug(\"Upgraded %s\", \"all packages\" if all_pkgs else pkgs)\n-    return {\"upgraded\": \"all\" if all_pkgs else pkgs}\n-\n-\n-def list_pkgs() -> list[str]:\n-    \"\"\"Return the current dependency list as plain strings.\"\"\"\n-    txt = _rt.list_pkgs()\n-    _log.debug(\"Listed %d packages\", len(txt.splitlines()))\n-    return txt.splitlines()\n"
                }
            ],
            "date": 1748231745841,
            "name": "Commit-0",
            "content": "# --------------------------------------------------------------------------- #\n# Higher-level helpers (used by ops.deps)                                     #\n# --------------------------------------------------------------------------- #\ndef add(pkgs: list[str], *, dev: bool = False) -> None:\n    flags = \"--dev\" if dev else \"\"\n    call(f\"add {flags} {' '.join(pkgs)}\")\n\n\ndef remove(pkgs: list[str]) -> None:\n    call(f\"remove {' '.join(pkgs)}\")\n\n\ndef upgrade(all_pkgs: bool = False, pkgs: list[str] | None = None) -> None:\n    if all_pkgs:\n        call(\"upgrade --all\")\n    elif pkgs:\n        call(f\"upgrade {' '.join(pkgs)}\")\n\n\ndef list_pkgs() -> str:\n    return call(\"list\", capture=True) or \"\"\n"
        }
    ]
}
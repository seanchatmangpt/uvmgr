{
    "sourceFile": "src/uvmgr/runtime/__init__.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1748236689374,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1748236689374,
            "name": "Commit-0",
            "content": "\"\"\"\nuvmgr.runtime\n=============\n\nThe *side-effect* layer.  Anything here is allowed to:\n\n* spawn subprocesses\n* touch the network or filesystem directly\n* depend on heavy or optional third-party packages\n\nDesign goals for this ``__init__``:\n\n1. **Document** the available runtime helpers in **__all__**.\n2. Provide a **lazy importer** via ``__getattr__`` so\n   `from uvmgr.runtime import uv, ai` works without importing *every* helper at\n   start-up (keeps `uvmgr` CLI snappy and avoids ImportErrors if an optional\n   dep like *spiffworkflow* isnâ€™t installed).\n3. Make adding new runtime helpers as simple as dropping a file and listing\n   its name in **__all__**.\n\nWhenever you create a new file under ``src/uvmgr/runtime/``, just add its\nbasename (without ``.py``) to **__all__** below.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport importlib\nimport sys\nfrom types import ModuleType\nfrom typing import Final, List\n\n# --------------------------------------------------------------------------- #\n# Update this list when you add/remove runtime helpers\n# --------------------------------------------------------------------------- #\n__all__: Final[List[str]] = [\n    \"uv\",        # thin wrapper around the `uv` CLI\n    \"exec\",      # run arbitrary Python scripts\n    \"poetask\",   # wrapper for `poe <task>`\n    \"project\",   # copier scaffold helpers\n    \"build\",     # python -m build + twine upload\n    \"release\",   # commitizen bump/changelog\n    \"ai\",        # DSPy LM factory (OpenAI / Ollama)\n    \"aps\",       # APScheduler singleton\n    \"remote\",    # rsync + tmux launcher\n    \"agent\",     # BPMN runner (spiffworkflow)\n]\n\n_PREFIX = __name__ + \".\"\n\n\n# --------------------------------------------------------------------------- #\n# Lazy loader\n# --------------------------------------------------------------------------- #\ndef __getattr__(name: str) -> ModuleType:\n    \"\"\"\n    Import the requested runtime helper on first access, cache it in\n    ``sys.modules``, then return it.\n    \"\"\"\n    if name not in __all__:\n        raise AttributeError(name)\n\n    module = importlib.import_module(_PREFIX + name)\n    # cache for subsequent look-ups\n    setattr(sys.modules[__name__], name, module)\n    return module\n"
        }
    ]
}
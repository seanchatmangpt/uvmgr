{
    "sourceFile": "NEW-PROJECT.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1748296892666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1748296892666,
            "name": "Commit-0",
            "content": "# Creating a New Typer CLI Project\n\nThis guide explains how to create a new Typer-based CLI project following the structure and best practices of uvmgr.\n\n## Project Structure Overview\n\n```\nmycli/\n├── docker-compose.yml      # Container orchestration\n├── Dockerfile             # Container definition\n├── pyproject.toml         # Project metadata and dependencies\n├── README.md             # Project documentation\n├── src/\n│   └── mycli/            # Main package\n│       ├── __init__.py\n│       ├── cli.py        # Root CLI application\n│       ├── commands/     # Command modules\n│       │   ├── __init__.py\n│       │   └── [command].py\n│       ├── core/         # Core utilities\n│       │   ├── __init__.py\n│       │   └── [utility].py\n│       ├── ops/          # Business logic\n│       │   ├── __init__.py\n│       │   └── [operation].py\n│       └── runtime/      # Runtime implementations\n│           ├── __init__.py\n│           └── [runtime].py\n└── tests/                # Test suite\n    ├── __init__.py\n    └── test_*.py\n```\n\n## Step 1: Project Setup\n\n1. Create a new project using Copier (recommended) or manually:\n\n```bash\n# Using Copier (recommended)\nuvmgr new mycli\n\n# Or manually\nmkdir mycli && cd mycli\n```\n\n2. Initialize the project with `pyproject.toml`:\n\n```toml\n[project]\nname = \"mycli\"\nversion = \"0.1.0\"\ndescription = \"My CLI Application\"\nauthors = [\n    {name = \"Your Name\", email = \"your.email@example.com\"},\n]\ndependencies = [\n    \"typer>=0.9.0\",\n    \"rich>=13.0.0\",\n    \"click>=8.0.0\",\n]\nrequires-python = \">=3.9\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.ruff]\nline-length = 88\ntarget-version = \"py39\"\n\n[tool.mypy]\npython_version = \"3.9\"\nstrict = true\n```\n\n## Step 2: Core Structure\n\n### 1. Root CLI (`src/mycli/cli.py`)\n\n```python\n\"\"\"\nmycli.cli\n=========\n\nRoot Typer application with global options and command mounting.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport importlib\nfrom typing import Any\n\nimport typer\n\nfrom mycli.core.telemetry import setup_logging\n\n# Setup logging\nsetup_logging(\"INFO\")\n\n# Root application\napp = typer.Typer(\n    add_completion=False,\n    rich_markup_mode=\"rich\",\n    help=\"**mycli** – Your CLI description.\",\n)\n\n# Global options\ndef _json_cb(ctx: typer.Context, value: bool):\n    if value:\n        ctx.meta[\"json\"] = True\n\n@app.callback()\ndef _root(\n    ctx: typer.Context,\n    json_: bool = typer.Option(\n        False,\n        \"--json\",\n        \"-j\",\n        callback=_json_cb,\n        is_eager=True,\n        help=\"Print machine-readable JSON and exit\",\n    ),\n):\n    \"\"\"Global callback for shared options.\"\"\"\n\n# Mount commands\ncommands_pkg = importlib.import_module(\"mycli.commands\")\n\nfor verb in commands_pkg.__all__:\n    mod = importlib.import_module(f\"mycli.commands.{verb}\")\n    sub_app = next(\n        (obj for obj in mod.__dict__.values() if isinstance(obj, typer.Typer)),\n        None,\n    )\n    if sub_app is None:\n        raise ImportError(f\"`{verb}` has no Typer sub-app\")\n    app.add_typer(sub_app, name=verb.replace(\"_\", \"-\"))\n```\n\n### 2. Command Module (`src/mycli/commands/example.py`)\n\n```python\n\"\"\"\nmycli.commands.example\n=====================\n\nExample command implementation.\n\"\"\"\n\nimport typer\nfrom rich.console import Console\n\nfrom mycli.ops.example import ExampleOperation\nfrom mycli.core.shell import maybe_json\n\napp = typer.Typer(help=\"Example command description.\")\nconsole = Console()\n\n@app.command()\ndef run(\n    ctx: typer.Context,\n    name: str = typer.Argument(..., help=\"Name to greet\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Enable verbose output\"),\n):\n    \"\"\"Run the example command.\"\"\"\n    op = ExampleOperation()\n    result = op.execute(name=name, verbose=verbose)\n    \n    # Handle JSON output\n    maybe_json(ctx, result)\n    \n    # Rich console output\n    console.print(f\"[green]Hello, {name}![/green]\")\n```\n\n### 3. Operation Module (`src/mycli/ops/example.py`)\n\n```python\n\"\"\"\nmycli.ops.example\n================\n\nBusiness logic for the example command.\n\"\"\"\n\nfrom dataclasses import dataclass\nfrom typing import Any, Dict\n\n@dataclass\nclass ExampleOperation:\n    \"\"\"Example operation implementation.\"\"\"\n    \n    def execute(self, name: str, verbose: bool = False) -> Dict[str, Any]:\n        \"\"\"Execute the example operation.\"\"\"\n        # Implement business logic here\n        return {\n            \"status\": \"success\",\n            \"message\": f\"Hello, {name}!\",\n            \"verbose\": verbose,\n        }\n```\n\n### 4. Core Utilities (`src/mycli/core/telemetry.py`)\n\n```python\n\"\"\"\nmycli.core.telemetry\n===================\n\nLogging and telemetry setup.\n\"\"\"\n\nimport logging\nfrom typing import Optional\n\ndef setup_logging(level: str = \"INFO\", otel: Optional[bool] = None) -> None:\n    \"\"\"Configure logging for the application.\"\"\"\n    logging.basicConfig(\n        level=getattr(logging, level),\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    )\n```\n\n## Step 3: Testing Structure\n\n### 1. Test Configuration (`tests/conftest.py`)\n\n```python\n\"\"\"\nTest configuration and fixtures.\n\"\"\"\n\nimport pytest\nfrom typer.testing import CliRunner\n\n@pytest.fixture\ndef cli_runner():\n    \"\"\"Create a Typer CLI runner for testing.\"\"\"\n    return CliRunner()\n\n@pytest.fixture\ndef mock_operation(monkeypatch):\n    \"\"\"Mock the example operation.\"\"\"\n    def mock_execute(*args, **kwargs):\n        return {\"status\": \"success\", \"message\": \"Mocked response\"}\n    \n    monkeypatch.setattr(\"mycli.ops.example.ExampleOperation.execute\", mock_execute)\n```\n\n### 2. Command Tests (`tests/test_example.py`)\n\n```python\n\"\"\"\nTests for the example command.\n\"\"\"\n\nimport pytest\nfrom typer.testing import CliRunner\n\ndef test_example_command(cli_runner: CliRunner):\n    \"\"\"Test the example command.\"\"\"\n    result = cli_runner.invoke(app, [\"run\", \"World\"])\n    assert result.exit_code == 0\n    assert \"Hello, World!\" in result.stdout\n\ndef test_example_command_json(cli_runner: CliRunner):\n    \"\"\"Test the example command with JSON output.\"\"\"\n    result = cli_runner.invoke(app, [\"run\", \"World\", \"--json\"])\n    assert result.exit_code == 0\n    assert '\"status\": \"success\"' in result.stdout\n```\n\n## Step 4: Development Tools\n\n1. Add development dependencies to `pyproject.toml`:\n\n```toml\n[project.optional-dependencies]\ndev = [\n    \"pytest>=7.0.0\",\n    \"pytest-cov>=4.0.0\",\n    \"ruff>=0.1.0\",\n    \"mypy>=1.0.0\",\n    \"pre-commit>=3.0.0\",\n]\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\"]\naddopts = \"--cov=mycli --cov-report=xml:reports/coverage.xml\"\n\n[tool.ruff]\nselect = [\"E\", \"F\", \"B\", \"I\"]\nignore = []\n\n[tool.mypy]\nplugins = [\"pydantic.mypy\"]\n```\n\n2. Add pre-commit configuration (`.pre-commit-config.yaml`):\n\n```yaml\nrepos:\n-   repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0\n    hooks:\n    -   id: trailing-whitespace\n    -   id: end-of-file-fixer\n    -   id: check-yaml\n    -   id: check-added-large-files\n\n-   repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.1.0\n    hooks:\n    -   id: ruff\n        args: [--fix]\n\n-   repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.0.0\n    hooks:\n    -   id: mypy\n        additional_dependencies: [types-all]\n```\n\n## Step 5: Container Support\n\n### 1. Dockerfile\n\n```dockerfile\nFROM python:3.9-slim\n\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    git \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Install Python package\nCOPY . .\nRUN pip install --no-cache-dir -e .\n\nENTRYPOINT [\"mycli\"]\n```\n\n### 2. Docker Compose\n\n```yaml\nversion: '3.8'\n\nservices:\n  mycli:\n    build: .\n    volumes:\n      - .:/app\n    environment:\n      - PYTHONPATH=/app\n```\n\n## Best Practices\n\n1. **Command Organization**\n   - Keep commands modular and focused\n   - Use the `commands/` directory for CLI definitions\n   - Implement business logic in `ops/`\n   - Place shared utilities in `core/`\n\n2. **Error Handling**\n   - Use custom exceptions for business logic\n   - Implement graceful error handling in commands\n   - Provide meaningful error messages\n\n3. **Testing**\n   - Write tests for all commands\n   - Use fixtures for common setup\n   - Test both success and error cases\n   - Include integration tests\n\n4. **Documentation**\n   - Document all commands and options\n   - Include examples in docstrings\n   - Keep README.md up to date\n   - Use type hints consistently\n\n5. **Development Workflow**\n   - Use pre-commit hooks\n   - Run tests before committing\n   - Keep dependencies up to date\n   - Follow semantic versioning\n\n## Usage Example\n\n```bash\n# Install the package\npip install -e .\n\n# Run the CLI\nmycli --help\nmycli example run World\nmycli example run World --json\n\n# Development\npre-commit install\npytest\nruff check .\nmypy .\n```\n\n## Next Steps\n\n1. Add more commands following the same pattern\n2. Implement additional core utilities as needed\n3. Add CI/CD pipeline configuration\n4. Create comprehensive documentation\n5. Add more test coverage\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Make your changes\n4. Run tests and linting\n5. Submit a pull request\n\n## License\n\n[Add appropriate license information] "
        }
    ]
}
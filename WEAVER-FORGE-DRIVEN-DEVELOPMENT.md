# Weaver Forge-Driven Development in uvmgr

## Vision: uvmgr as a Weaver-First, Forge-Generated Platform

Imagine uvmgr was conceived from day one as a Weaver Forge-driven project. Every command, operation, and workflow is scaffolded, validated, and documented using semantic conventions and code generation powered by Weaver Forge templates—similar to the Hygen approach, but with full OpenTelemetry and semantic rigor.

---

## 1. Three-Layer Command Architecture: Forge-First

Every uvmgr command is generated as a three-layer structure:

- **CLI Layer**: User-facing Typer/Rich CLI, argument parsing, help, and UX
- **Ops Layer**: Business logic, orchestration, and integration with external tools
- **Core Layer**: Pure functions, semantic conventions, and telemetry primitives

All three layers are scaffolded from Forge templates, ensuring:
- Consistent structure and naming
- Built-in OpenTelemetry instrumentation
- Semantic convention compliance
- Test and doc scaffolding

---

## 2. Example: Forge Template Structure (Hygen-Style)

### Directory Layout

```
weaver-forge/templates/
  ├── cli-command.forge.yaml
  ├── ops-command.forge.yaml
  ├── core-command.forge.yaml
  ├── test-command.forge.yaml
  └── doc-command.forge.yaml
```

### Template: CLI Command (cli-command.forge.yaml)

```yaml
template: cli-command
outputs:
  - path: src/uvmgr/commands/{{ command_name }}.py
    content: |
      """
      uvmgr.commands.{{ command_name }} - CLI Layer
      Generated by Weaver Forge
      """
      import typer
      from rich.console import Console
      from uvmgr.ops.{{ command_name }} import {{ command_name }}_ops
      from uvmgr.core.instrumentation import instrument_command

      app = typer.Typer()
      console = Console()

      @app.command("{{ command_action }}")
      @instrument_command("{{ command_name }}_{{ command_action }}")
      def {{ command_action }}(...):
          """{{ command_docstring }}"""
          result = {{ command_name }}_ops.{{ command_action }}(...)
          console.print(result)
```

### Template: Ops Command (ops-command.forge.yaml)

```yaml
template: ops-command
outputs:
  - path: src/uvmgr/ops/{{ command_name }}.py
    content: |
      """
      uvmgr.ops.{{ command_name }} - Ops Layer
      Generated by Weaver Forge
      """
      from uvmgr.core.{{ command_name }} import {{ command_name }}_core
      from uvmgr.core.telemetry import span

      def {{ command_action }}(...):
          with span("{{ command_name }}.{{ command_action }}"):
              return {{ command_name }}_core.{{ command_action }}(...)
```

### Template: Core Command (core-command.forge.yaml)

```yaml
template: core-command
outputs:
  - path: src/uvmgr/core/{{ command_name }}.py
    content: |
      """
      uvmgr.core.{{ command_name }} - Core Layer
      Generated by Weaver Forge
      """
      from uvmgr.core.semconv import {{ command_name|capitalize }}Attributes
      from uvmgr.core.telemetry import add_span_attributes

      def {{ command_action }}(...):
          add_span_attributes({{ command_name|capitalize }}Attributes.OPERATION, "{{ command_action }}")
          # ... core logic ...
          return {"status": "success"}
```

### Template: Test Command (test-command.forge.yaml)

```yaml
template: test-command
outputs:
  - path: tests/{{ layer }}/test_{{ command_name }}.py
    content: |
      import pytest
      from uvmgr.{{ layer }}.{{ command_name }} import {{ command_action }}

      def test_{{ command_action }}():
          result = {{ command_action }}(...)
          assert result["status"] == "success"
```

### Template: Doc Command (doc-command.forge.yaml)

```yaml
template: doc-command
outputs:
  - path: docs/commands/{{ command_name }}.md
    content: |
      # {{ command_name|capitalize }} Command
      
      **Layer:** {{ layer }}
      
      ## Description
      {{ command_docstring }}
      
      ## Usage
      ```bash
      uvmgr {{ command_name }} {{ command_action }} [OPTIONS]
      ```
      
      ## Options
      - ...
```

---

## 3. Forge-Driven Workflow: How It Works

1. **Define Command Spec**
   - Example: `uvmgr forge generate command --name deps --actions add,remove,list`

2. **Forge Generates All Layers**
   - CLI, ops, core, test, and doc files are created from templates
   - Semantic conventions and OTEL spans are injected automatically

3. **Developer Fills in Core Logic**
   - Only the business logic in core/ops needs to be implemented
   - All boilerplate, wiring, and telemetry is handled by Forge

4. **Continuous Compliance**
   - Any new command or action is always scaffolded with semantic conventions, tests, and docs
   - Refactoring or adding new actions is as simple as re-running Forge

---

## 4. Example: Generating a New Command

```bash
uvmgr forge generate command --name build --actions wheel,sdist,exe
```

**Result:**
- `src/uvmgr/commands/build.py` (CLI)
- `src/uvmgr/ops/build.py` (Ops)
- `src/uvmgr/core/build.py` (Core)
- `tests/commands/test_build.py`, `tests/ops/test_build.py`, ...
- `docs/commands/build.md`

All files are pre-wired for OpenTelemetry, semantic conventions, and best practices.

---

## 5. Benefits of Forge-Driven Development

- **Consistency**: All commands follow the same structure and conventions
- **Observability**: 100% OTEL coverage by default
- **Speed**: New features are scaffolded in seconds
- **Quality**: Tests and docs are always generated
- **Extensibility**: Adding new layers or conventions is just a template update
- **Enterprise-Ready**: Semantic conventions and compliance are built-in

---

## 6. Conclusion

If uvmgr had been designed from the start with Weaver Forge-driven development, every command, operation, and workflow would be:
- Consistently structured
- Fully instrumented
- Semantically compliant
- Rapidly extensible
- Easy to test and document

**Weaver Forge is not just a code generator—it's a foundation for sustainable, observable, and enterprise-grade Python development.** 
"""
Example of generated command instrumentation for uvmgr using Weaver Forge patterns.
This shows what the generated code would look like for the deps command.
"""

from collections.abc import Callable
from functools import wraps
from typing import Any, List, Optional

import typer
from opentelemetry import trace
from opentelemetry.semconv.trace import SpanAttributes
from opentelemetry.trace import Status, StatusCode

from ...core.telemetry import metric_counter, record_exception, span


# Generated decorator for command instrumentation
def instrument_command(
    name: str = None,
    command_type: str = "cli",
    track_args: bool = True
):
    """
    Decorator to instrument CLI commands with OTEL.
    
    Generated by Weaver Forge for uvmgr command telemetry.
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            command_name = name or func.__name__
            span_name = f"{command_type}.command.{command_name}"

            # Extract meaningful attributes from args/kwargs
            attributes = {
                "cli.command": command_name,
                "cli.module": func.__module__.split(".")[-1],
                SpanAttributes.CODE_FUNCTION: func.__name__,
                SpanAttributes.CODE_NAMESPACE: func.__module__,
            }

            # Add CLI-specific attributes
            if track_args and args:
                # Safely serialize args for telemetry
                attributes["cli.args.count"] = len(args)
                if hasattr(args[0], "__dict__"):  # Typer context
                    attributes["cli.interactive"] = str(args[0].interactive)

            with span(
                span_name,
                span_kind=trace.SpanKind.SERVER,  # CLI commands are "server" spans
                attributes=attributes
            ) as current_span:
                # Increment command counter metric
                metric_counter(f"cli.command.{command_name}.calls")

                try:
                    # Add pre-execution event
                    current_span.add_event(
                        "command.started",
                        {"cli.command": command_name}
                    )

                    # Execute the actual command
                    result = func(*args, **kwargs)

                    # Success - set OK status
                    current_span.set_status(Status(StatusCode.OK))
                    current_span.add_event(
                        "command.completed",
                        {"cli.command": command_name, "cli.success": True}
                    )

                    return result

                except typer.Exit as e:
                    # Normal exit (like --help)
                    exit_code = e.exit_code
                    if exit_code == 0:
                        current_span.set_status(Status(StatusCode.OK))
                    else:
                        current_span.set_status(
                            Status(StatusCode.ERROR, f"Exit code: {exit_code}")
                        )
                    current_span.set_attribute("cli.exit_code", exit_code)
                    raise

                except Exception as e:
                    # Error - record exception and set error status
                    record_exception(e, escaped=True)
                    current_span.set_status(
                        Status(StatusCode.ERROR, str(e))
                    )
                    current_span.add_event(
                        "command.failed",
                        {
                            "cli.command": command_name,
                            "cli.success": False,
                            "exception.type": type(e).__name__,
                        }
                    )

                    # Increment error counter
                    metric_counter(f"cli.command.{command_name}.errors")
                    raise

        return wrapper
    return decorator


# Example instrumented deps command module
# This shows how the generated instrumentation would be applied

app = typer.Typer()


@app.command()
@instrument_command("deps_add", track_args=True)
def add(
    packages: list[str] = typer.Argument(..., help="Package names to add"),
    dev: bool = typer.Option(False, "--dev", "-d", help="Add as dev dependency"),
    pre: bool = typer.Option(False, "--pre", help="Allow pre-release versions"),
):
    """Add package dependencies to the project."""
    # The decorator automatically creates spans and tracks metrics
    # Original command implementation continues here


@app.command()
@instrument_command("deps_remove", track_args=True)
def remove(
    packages: list[str] = typer.Argument(..., help="Package names to remove"),
):
    """Remove package dependencies from the project."""
    # Automatically instrumented


@app.command()
@instrument_command("deps_list")
def list_deps(
    dev: bool = typer.Option(False, "--dev", help="List only dev dependencies"),
    format: str = typer.Option("table", "--format", help="Output format"),
):
    """List all project dependencies."""
    # The span will include format information
    with trace.get_current_span() as span:
        span.set_attribute("deps.list.format", format)
        span.set_attribute("deps.list.dev_only", dev)

    # Original implementation


@app.command()
@instrument_command("deps_update")
def update(
    packages: list[str] | None = typer.Argument(None, help="Specific packages to update"),
    all: bool = typer.Option(False, "--all", help="Update all packages"),
):
    """Update package dependencies."""
    with trace.get_current_span() as span:
        if packages:
            span.set_attribute("deps.update.packages", ",".join(packages))
            span.set_attribute("deps.update.count", len(packages))
        span.set_attribute("deps.update.all", all)

    # Original implementation


# Subcommand instrumentation pattern
def instrument_subcommand(parent_command: str):
    """Decorator for subcommands to maintain trace hierarchy."""
    def decorator(func: Callable) -> Callable:
        return instrument_command(
            f"{parent_command}_{func.__name__}",
            command_type="cli.subcommand"
        )(func)
    return decorator


# Example of batch operations with child spans
@app.command()
@instrument_command("deps_sync")
def sync():
    """Sync all dependencies with lock file."""
    current_span = trace.get_current_span()

    # Create child spans for each phase
    with span("deps.sync.read_lockfile") as read_span:
        read_span.set_attribute("file.path", "uv.lock")
        # Read lock file

    with span("deps.sync.compare") as compare_span:
        compare_span.set_attribute("deps.differences.count", 5)  # example
        # Compare current vs locked

    with span("deps.sync.install") as install_span:
        install_span.set_attribute("deps.install.count", 3)
        # Install missing deps

    current_span.add_event("sync.completed", {"deps.synced": True})
